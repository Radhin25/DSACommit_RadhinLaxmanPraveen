507. Perfect Number

A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.
Given an integer n, return true if n is a perfect number, otherwise return false.

ðŸ’¡ Brute-Force Logic:
We are going to:

Loop from 1 to num - 1
Check every number i if it is a divisor of num â†’ i.e., num % i == 0
If it divides the number, we add it to sum
Finally, if sum == num, then it's a perfect number, otherwise not.

Inefficient for large values of num
Time Complexity: O(n)
(We check all numbers from 1 to num-1)


ðŸš€ Optimized Approach
âœ… Core Idea:
For every divisor i of a number num, there is a paired divisor num / i.
For example, if i = 2 divides 28, then 28 / 2 = 14 is also a divisor. So you get both 2 and 14 from a single check.
To avoid duplicate work, we only loop till âˆšnum (square root of num).

ðŸ§  Step-by-Step Logic

bool checkPerfectNumber(int num) {
    if (num <= 1) return false; // 0 and 1 can't be perfect numbers

    int sum = 1; // 1 is a divisor of every number

    // Run the loop from 2 to sqrt(num)
    for (int i = 2; i * i <= num; ++i) {

        if (num % i == 0) {
            sum += i;

            // Add the paired divisor only if it's different (to avoid duplicates)
            if (i != num / i) {
                sum += num / i;
            }
        }
    }

    // Finally check if sum of divisors equals the number
    return sum == num;
}
ðŸ“Œ Why i * i <= num Instead of i <= sqrt(num)?
We write:
for (int i = 2; i * i <= num; ++i)
instead of:

for (int i = 2; i <= sqrt(num); ++i)
âœ… Reason:
Using i * i <= num avoids calling sqrt(num) which is a function call and can be costly in terms of time (especially in tight loops).

i * i <= num uses integer arithmetic â†’ faster
sqrt(num) uses floating-point arithmetic â†’ slower and risk of precision error
So this trick is used in competitive programming and optimized code.

ðŸ§  Why We Start From i = 2?
Because we already added 1 to the sum, as 1 is a divisor of all numbers.
Also, num itself is excluded (as per the problem), so we donâ€™t consider it.

ðŸ” Example: num = 28
Loop from 2 to sqrt(28) = 5.x
Divisors:
2 â†’ 28/2 = 14 â†’ sum += 2 + 14
4 â†’ 28/4 = 7 â†’ sum += 4 + 7
Final sum = 1 + 2 + 14 + 4 + 7 = 28

âœ… Itâ€™s a Perfect Number

âœ… Time Complexity: O(âˆšn)
Operation	Time
Looping through divisors up to âˆšn	O(âˆšn)
Constant operations inside loop	O(1)
Total	O(âˆšn)

Much better than brute force O(n)!

ðŸ“Œ Final Notes:
num <= 1 â†’ directly return false

sum starts at 1

Loop from i = 2 to i * i <= num

Always avoid adding duplicate divisor (i == num/i)

Return sum == num
